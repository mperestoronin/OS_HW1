# OS_HW1
## Выполнил Пересторонин Максим Дмитриевич БПИ 217 на оценку 8

Вариант 22:
```Разработать программу, вычисляющую число вхождений различных знаков препинания в заданной ASCII-строке.```


Результаты тестирования всех программ можно посмотреть [тут]()
## На 4 балла:
Сначала программа проверяет, что ей передали ровно два аргумента командной строки
(имена входного и выходного файлов). Если количество аргументов неверно,
программа выводит сообщение об использовании и завершает работу.
Два неименнованных канала создаются с помощью `pipe()`.
Эти каналы используются для обмена данными между родительским процессом и его дочерними процессами.
Три дочерних процесса создаются с помощью `fork()`.
Каждый дочерний процесс выполняет свою функцию, как описано ниже.

Первый дочерний процесс (child1) отвечает за чтение входного файла и запись его содержимого в первый канал.
Это делается путем вызова функции `read_from_file`.

Второй дочерний процесс (child2) считывает данные из первого канала и обрабатывает их с помощью программы под названием punctuation_counter (представлено в отедльном файле).
Для этого вызывается функция execute_punctuation_counter.
Третий дочерний процесс (child3) считывает данные из второго канала и записывает результаты в выходной файл.
Это делается через функцию `write_to_file`.

После создания дочерних процессов родительский процесс закрывает все неиспользуемые каналы и ожидает завершения дочерних процессов с помощью `waitpid`.

## На 5 баллов
Данная программа структурно почти ничем не отличается от предидущей.
Для полноты картины рекомендую посмотреть отчет на 4 балла.

В этот раз я просто использовал именнованные каналы pipe1 и pipe2 (в коде для удобства стоят `#define PIPE1_NAME "pipe1"` и `#define PIPE2_NAME "pipe2"`), созданные при помощи `mkfifo()`.

В конце мы используем `unlink()`, чтобы удалить наши именованные каналы.
Если бы именованные каналы не были удалены с помощью `unlink()`, они продолжали бы существовать в системе в виде специальных файлов даже после завершения работы программы. Это может вызвать проблемы в будущем, например, при попытке создать новые именованные каналы с тем же именем, что и у существующих.

## На 6 баллов
На этот раз программа создает два дочерних процесса для выполнения двух задач одновременно. Программа принимает два аргумента командной строки: имя входного файла и имя выходного файла.

Основная функция запускается с проверки того, было ли предоставлено 3 аргумента (имя программы, имя входного файла и имя выходного файла).

Затем программа создает два канала (`pipe1` и `pipe2`), используя функцию `pipe()` из библиотеки <unistd.h>. Каналы используются для обмена данными между двумя дочерними процессами и родительским процессом.

После создания каналов программа разветвляет два дочерних процесса (`child1` и `child2`) с помощью функции `fork()` из библиотеки <sys/types.h>. 
Процесс `child1` выполняет функцию `read_and_write()`, которая принимает дескрипторы файлов `read_pipe` и `write_pipe`, а также имена входных и выходных файлов. Он открывает входной файл с помощью функции `open()`, считывает данные из входного файла в буфер размера `BUFFER_SIZE` и записывает данные в `write_pipe`. Как только данных для чтения больше нет, он закрывает `write_pipe` и дескриптор входного файла.

Второй очерний процесс выполняет функцию `execute_punctuation_counter()`, которая принимает дескрипторы файлов `read_pipe` и `write_pipe`. Функция использует функцию `dup2()` из библиотеки <unistd.h> для дублирования дескриптора файла `read_pipe` в `STDIN_FILENO` и дескриптора файла `write_pipe` в `STDOUT_FILENO`. Затем он выполняет исполняемый файл `punctuation_counter`, используя функцию `execlp()` из библиотеки <unistd.h>.

После того, как оба дочерних процесса разветвлены, родительский процесс закрывает каналы, `pipe1[0], pipe1[1], pipe2[0] и pipe2[1]`. Затем он ожидает завершения обоих дочерних процессов, используя функцию `waitpid()` из библиотеки <sys/wait.h>.

## На 7 баллов
Как и в случае с программой на 5 баллов, данная программа особо не отличается от предидущей. Только в этот раз мы используем именнованные каналы `PIPE1_NAME` и `PIPE2_NAME`, созданные через функцию `mkfifo`. См отчет на 6 баллов для полной картины.

## На 8 баллов
### Небольшой гайд по запуску:
для запуска написать следующие команды в терминале:
- `mkfifo pipe1`
- `mkfifo pipe2`
- `mkfifo sync_pipe`

это создаст `pipe1, pipe2, sync_pipe`
после чего пишем `./main8` в одном окне терминала, а в другом `./main8rw input.txt output.txt`
### Непосредственно про саму программу:
Эта программа представляет собой простой пример межпроцессного взаимодействия между двумя программами, работающими одновременно.
Программа состоит из двух отдельных частей, каждая из которых предназначена для запуска одновременно с другой. Одна часть программы считывает входной текстовый файл и записывает его содержимое в канал, в то время как другая часть считывает из канала, подсчитывает количество знаков препинания и записывает результат в другой канал.

Две части программы взаимодействуют друг с другом, используя два именованных канала и канал синхронизации. Канал синхронизации используется для того, чтобы передать процессу, подсчитывающему знаки препинания, что входной файл уже был загружен в канал (тем самым запустить его).

Первая часть программы начинается с ожидания сигнала от канала синхронизации, указывающего на то, что вторая часть программы готова начать обработку данных. Как только сигнал получен, он открывает первый именованный канал для записи и второй именованный канал для чтения, а затем начинает считывать входной текстовый файл. Когда он считывает данные из входного файла, он записывает их в первый именованный канал. Как только весь входной файл был прочитан и записан в канал, эта часть программы закрывает канал и завершает работу.

Вторая часть программы начинается с ожидания сигнала синхронизации по тому же каналу. Как только сигнал получен, он открывает первый именованный канал для чтения и второй именованный канал для записи. Затем он перенаправляет свои стандартные входные и выходные потоки в первый и второй каналы соответственно, используя системный вызов `dup2()`. Наконец, он запускает внешнюю программу под названием punctuation_counter (находится в отдельном файле, как и в других программах), используя системный вызов `execlp()`. Эта внешняя программа принимает входные данные из своего стандартного входного потока (который теперь является первым именованным каналом) и записывает свои выходные данные в свой стандартный выходной поток (который теперь является вторым именованным каналом).

По критериям надо указать имена потоков, так что вот:
```
#define PIPE1_NAME "pipe1"
#define PIPE2_NAME "pipe2"
#define SYNC_PIPE_NAME "sync_pipe"
```
Наконец, вторая часть программы считывает выходные данные из второго именованного канала и записывает их в выходной файл. Как только все выходные данные будут прочитаны и записаны, эта часть программы закрывает два именованных канала и завершает работу.
