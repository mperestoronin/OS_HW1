# Описание работы программы:
На этот раз программа создает два дочерних процесса для выполнения двух задач одновременно. Программа принимает два аргумента командной строки: имя входного файла и имя выходного файла.

Основная функция запускается с проверки того, было ли предоставлено 3 аргумента (имя программы, имя входного файла и имя выходного файла).

Затем программа создает два канала (pipe1 и pipe2), используя функцию pipe() из библиотеки <unistd.h>. Каналы используются для обмена данными между двумя дочерними процессами и родительским процессом.

После создания каналов программа разветвляет два дочерних процесса (child1 и child2) с помощью функции fork() из библиотеки <sys/types.h>. 
Процесс child1 выполняет функцию read_and_write(), которая принимает дескрипторы файлов read_pipe и write_pipe, а также имена входных и выходных файлов. Он открывает входной файл с помощью функции open(), считывает данные из входного файла в буфер размера BUFFER_SIZE и записывает данные в write_pipe. Как только данных для чтения больше нет, он закрывает write_pipe и дескриптор входного файла.

Дочерний процесс2 выполняет функцию execute_punctuation_counter(), которая принимает дескрипторы файлов read_pipe и write_pipe. Функция использует функцию dup2() из библиотеки <unistd.h> для дублирования дескриптора файла read_pipe в STDIN_FILENO и дескриптора файла write_pipe в STDOUT_FILENO. Затем он выполняет исполняемый файл punctuation_counter, используя функцию execlp() из библиотеки <unistd.h>.

После того, как оба дочерних процесса разветвлены, родительский процесс закрывает каналы, pipe1[0], pipe1[1], pipe2[0] и pipe2[1]. Затем он ожидает завершения обоих дочерних процессов, используя функцию waitpid() из библиотеки <sys/wait.h>.
